import { gstApi } from "@/api";
import type {
  CreateIncidentRequest,
  ResolveIncidentRequest,
  ProcessResponse,
  Incidence,
  GenerateReportRequest,
  ReportResponse,
} from "@/models/incidents";
import type { AssignIncidentRequest, Revisor } from "@/models/supervisor";

// ========================================
// GESTI√ìN DE PROCESOS (ACCESO GLOBAL)
// ========================================

/**
 * Obtener todos los procesos del sistema (acceso global para supervisores)
 * GET /api/v1/processes/supervisor
 * Los supervisores tienen acceso global a todos los procesos en revisi√≥n
 */
export const getAllProcesses = async (): Promise<ProcessResponse[]> => {
  try {
    const { data } = await gstApi.get<ProcessResponse[]>("/processes/supervisor");
    return data;
  } catch (err: any) {
    const message =
      err?.response?.data?.message ||
      err?.message ||
      "Error al obtener los procesos";
    throw new Error(message);
  }
};

// ========================================
// GESTI√ìN DE INCIDENCIAS (ACCESO GLOBAL)
// ========================================

interface CreateIncidentResponse {
  success: boolean;
  message: string;
  data?: any;
  [k: string]: any;
}

/**
 * Crear una incidencia
 * POST /api/v1/incidents
 */
export const createIncident = async (
  incidentData: CreateIncidentRequest
): Promise<CreateIncidentResponse> => {
  if (
    !incidentData.processId ||
    !incidentData.description ||
    !incidentData.evidence
  ) {
    throw new Error("processId, description y evidence son requeridos");
  }

  try {
    const formData = new FormData();
    formData.append("processId", incidentData.processId);
    formData.append("description", incidentData.description);
    formData.append("evidence", incidentData.evidence);

    const { data } = await gstApi.post<CreateIncidentResponse>(
      "/incidents",
      formData,
      {
        headers: {
          "Content-Type": "multipart/form-data",
        },
      }
    );

    return data;
  } catch (err: any) {
    const message =
      err?.response?.data?.message ||
      err?.message ||
      "Error al crear la incidencia";
    throw new Error(message);
  }
};

/**
 * Obtener incidencias de un proceso espec√≠fico
 * GET /api/v1/incidents/process/:processId
 */
export const getIncidencesByProcess = async (
  processId: string
): Promise<Incidence[]> => {
  try {
    const { data } = await gstApi.get<any[]>(`/incidents/process/${processId}`);

    console.log("üìã Datos raw del backend para proceso", processId, ":", data);

    const transformedData: Incidence[] = data
      .filter((incident: any) => {
        const incidentId = incident._id || incident.id;
        if (!incidentId) {
          console.warn("‚ö†Ô∏è Incidencia sin ID encontrada y omitida:", incident);
          return false;
        }
        return true;
      })
      .map((incident: any) => ({
        id: incident._id || incident.id,
        processId: processId,
        description: incident.description,
        status: incident.status?.toUpperCase() === "PENDIENTE" || incident.status?.toUpperCase() === "PENDING"
          ? "PENDING"
          : "RESOLVED",
        evidence: incident.evidence,
        createdAt: incident.createdAt,
        resolvedAt: incident.resolvedAt,
        createdBy: incident.createdBy,
      }));

    return transformedData;
  } catch (err: any) {
    const message =
      err?.response?.data?.message ||
      err?.message ||
      "Error al obtener las incidencias del proceso";
    throw new Error(message);
  }
};

/**
 * Obtener incidencias pendientes (supervisor)
 * GET /api/v1/incidents/pending
 */
export const getPendingIncidences = async (): Promise<Incidence[]> => {
  try {
    const { data } = await gstApi.get<any[]>("/incidents/pending");

    const transformedData: Incidence[] = data
      .filter((incident: any) => {
        const incidentId = incident._id || incident.id;
        if (!incidentId) {
          console.warn("‚ö†Ô∏è Incidencia sin ID encontrada y omitida:", incident);
          return false;
        }
        return true;
      })
      .map((incident: any) => ({
        id: incident._id || incident.id,
        processId: incident.processId?._id || incident.processId,
        description: incident.description,
        status: "PENDING",
        evidence: incident.evidence,
        createdAt: incident.createdAt,
        resolvedAt: incident.resolvedAt,
        createdBy: incident.createdBy,
      }));

    return transformedData;
  } catch (err: any) {
    const message =
      err?.response?.data?.message ||
      err?.message ||
      "Error al obtener las incidencias pendientes";
    throw new Error(message);
  }
};

/**
 * Obtener todas las incidencias de todos los procesos (ACCESO GLOBAL)
 * Los supervisores pueden ver todas las incidencias del sistema
 */
export const getAllIncidences = async (): Promise<Incidence[]> => {
  try {
    console.log("üîç Supervisor obteniendo todos los procesos del sistema...");
    const processes = await getAllProcesses();
    console.log("üìã Procesos encontrados:", processes.length, processes);

    const allIncidences: Incidence[] = [];

    for (const process of processes) {
      try {
        console.log(`üîç Obteniendo incidencias para proceso ${process.id}...`);
        const processIncidences = await getIncidencesByProcess(process.id);
        console.log(`‚úÖ Incidencias encontradas para proceso ${process.id}:`, processIncidences.length);
        allIncidences.push(...processIncidences);
      } catch (error) {
        console.warn(
          `‚ùå Error al obtener incidencias del proceso ${process.id}:`,
          error
        );
      }
    }

    console.log("üéØ Total de incidencias cargadas:", allIncidences.length);
    return allIncidences;
  } catch (err: any) {
    const message =
      err?.response?.data?.message ||
      err?.message ||
      "Error al obtener las incidencias";
    throw new Error(message);
  }
};

/**
 * Asignar incidencia a un revisor
 * PATCH /api/v1/incidents/:incidentId/assign
 */
export const assignIncident = async (
  incidentId: string,
  assignData: AssignIncidentRequest
): Promise<{ success: boolean; message: string }> => {
  try {
    const { data } = await gstApi.patch(
      `/incidents/${incidentId}/assign`,
      assignData
    );

    return { success: true, message: "Incidencia asignada correctamente" };
  } catch (err: any) {
    const message =
      err?.response?.data?.error ||
      err?.response?.data?.message ||
      err?.message ||
      "Error al asignar la incidencia";
    throw new Error(message);
  }
};

/**
 * Aprobar incidencia
 * PATCH /api/v1/incidents/:incidentId/approve
 */
export const approveIncident = async (
  incidentId: string
): Promise<{ success: boolean; message: string }> => {
  try {
    const { data } = await gstApi.patch(`/incidents/${incidentId}/approve`);

    return { success: true, message: "Incidencia aprobada correctamente" };
  } catch (err: any) {
    const message =
      err?.response?.data?.error ||
      err?.response?.data?.message ||
      err?.message ||
      "Error al aprobar la incidencia";
    throw new Error(message);
  }
};

/**
 * Resolver una incidencia
 * PATCH /api/v1/incidents/:id/resolve
 */
export const resolveIncident = async (
  incidentId: string,
  resolveData?: ResolveIncidentRequest
): Promise<{ success: boolean; message: string }> => {
  try {
    console.log("üîÑ Resolviendo incidencia:", incidentId, "con datos:", resolveData);

    const requestData = {
      resolvedAt: resolveData?.resolvedAt || new Date().toISOString(),
    };

    console.log("üì§ Enviando petici√≥n PATCH a:", `/incidents/${incidentId}/resolve`);
    console.log("üì§ Datos enviados:", requestData);

    const { data } = await gstApi.patch(
      `/incidents/${incidentId}/resolve`,
      requestData
    );

    console.log("‚úÖ Respuesta del servidor:", data);
    return { success: true, message: "Incidencia resuelta correctamente" };
  } catch (err: any) {
    console.error("‚ùå Error completo al resolver incidencia:", err);
    console.error("‚ùå Response data:", err?.response?.data);
    console.error("‚ùå Response status:", err?.response?.status);

    const message =
      err?.response?.data?.error ||
      err?.response?.data?.message ||
      err?.message ||
      "Error al resolver la incidencia";
    throw new Error(message);
  }
};

// ========================================
// GESTI√ìN DE REPORTES (ACCESO PRIVILEGIADO)
// ========================================

/**
 * Generar un reporte consolidado
 * POST /api/v1/reports
 * Validaci√≥n de Rol: Solo revisor y supervisor pueden generar reportes
 */
export const generateReport = async (
  reportData: GenerateReportRequest
): Promise<ReportResponse> => {
  try {
    console.log("üìä Supervisor generando reporte:", reportData);

    const { data } = await gstApi.post<ReportResponse>(
      "/reports",
      reportData
    );

    console.log("‚úÖ Reporte generado exitosamente:", data);
    return data;
  } catch (err: any) {
    console.error("‚ùå Error al generar reporte:", err?.response?.data || err);
    const message =
      err?.response?.data?.error ||
      err?.response?.data?.message ||
      err?.message ||
      "Error al generar el reporte";
    throw new Error(message);
  }
};

/**
 * Ver reporte generado
 * GET /api/v1/reports/:reportId
 */
export const getReport = async (reportId: string): Promise<ReportResponse> => {
  try {
    const { data } = await gstApi.get<ReportResponse>(`/reports/${reportId}`);
    return data;
  } catch (err: any) {
    const message =
      err?.response?.data?.error ||
      err?.response?.data?.message ||
      err?.message ||
      "Error al obtener el reporte";
    throw new Error(message);
  }
};